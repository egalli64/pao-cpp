1.1 Process memory

# Text/Code

Area in cui è tenuto il codice eseguibile
Potrebbe essere memoria read-only

# Data Segment

Area in cui sono gestite le variabili globali e statiche

Divisa in due parti
- Inizializzata seguendo le richieste del codice
- (BSS) Non esplicitamente inizializzata (messa a 0)

# Stack

Area a disposizione delle variabili locali, gestita automaticamente

# Free memory (heap)

Area a disposizione delle variabili locali, gestita via new / delete
	Singolo oggetto: new / delete
	Array di oggetti: new [] / delete []

È possibile usare le funzioni C: malloc / calloc / realloc e free
	Con le dovute cautele, e non mescolando blocchi di memoria gestiti in modo diverso

## Smart pointers

Nascondono la gestione della memoria sullo heap

### unique_ptr

Gestisce via puntatore un oggetto (o un array di oggetti) allocato sullo heap, che viene eliminato
- quando lo smart pointer esce dal suo scope
- o quando il puntatore a un altro oggetto è assegnato allo smart pointer via reset()

La template function factory make_unique() semplifica la creazione di un unique_ptr

### shared_ptr

Più shared_ptr possono gestire un unico oggetto
Un contatore, accedibile via use_count(), tiene traccia del loro numero
Quando use_count va a zero, ovvero l'ultimo shared_ptr sull'oggetto esce di scope, l'oggetto è eliminato

La template function factory make_shared() semplifica la creazione di un shared_ptr

--
Esiste anche il concetto di smart pointer debole, weak_ptr
Permette un accesso temporaneo a un oggetto posseduto da uno shared_ptr
