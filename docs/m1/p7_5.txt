7.5 Iteratori e algoritmi

Gli iteratori sono categorizzati in cinque gruppi, dal più debole al più forte

I due più deboli, a singola passata e monodirezionali, sono
- input: sola lettura
 - richiede gli operatori
    ++ (passaggio all'elemento successivo)
    * (dereferenziamento dell'iteratore per accesso al valore)
    == e != (ad es., poter determinare se si è raggiunta la fine del container)
- output: sola scrittura

Sempre monodirezionale, ma non a singola passata
- forward: lettura e scrittura

- bidirectional
    simile al forward, ma può moversi in due direzioni
- random
    può accedere a ogni elementi del container in tempo O(1)

Un algoritmo dovrebbe cercare di usare l'iteratore più debole possibile
- in modo da porter essere usato su più container

Il range-for, (parte del linguaggio e non della libreria standard) può operare anche su array raw
- Sostanzialmente richiede un input iterator

Agli algoritmi di accesso sequenziale e di ricerca basta un input iterator
- iterator find(iterator, iterator, const T&) // include algorithm
    richiede due iteratori che delimitino la ricerca (aperto a destra) e il valore cercato
    ritorna l'iteratore all'elemento trovato, o end()
- int accumulate(iterator, iterator, T) // include numeric
    richiede due iteratori che delimitino l'intervallo d'azione (aperto a destra) e il valore di partenza
    ritorna l'accumulo (in questa forma base, la somma), dei valori trovati

Ma, ad esempio, il quick sort richiede accesso casuale agli elementi
    Obbligatorio l'uso di un iteratore random, con limitazione del campo d'uso
- void sort(iterator, iterator) // include algorithm
    richiede due iteratori che delimitino l'intervallo d'azione (aperto a destra)
    ritorna void, l'ordinamento è fatto "in place"
