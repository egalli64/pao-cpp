2.1 Tipi standard

Come in C, anche in C++ i tipi di dati avere dimensioni diverse a seconda della piattaforma usata
L'operatore sizeof() ci dà la dimensione in byte del tipo o della variabile a cui viene applicato

bool: false o true 

char: 'a', '7', '@', ... 

numerici interi, possono essere signed (default) o unsigned
Da C++14 è possibile usare un apice per rendere più leggibili i numeri, es.: 123'456

short
int
long
long long

numerici reali, hanno sempre il segno

float
double
long double

operatori artimetici: +, -, *, /, %
da notare la differenza tra divisione intera e reale

operatori di confronto: ==, !=, <, <=, >, >=

operatori logici: !, &&, ||

operatori orientati al bit (su unsigned!): &, |, ^, ~

operatori di assegnamento: =, +=, -=, ..., ++, --
Attenzione al cast implicito nell'assegnamento!
Da C++11 si preferisce usare l'inizializzatore uniforme: {}

Cast esplicito via static_cast<type>()
Il cast C-style (type) corrisponde al reinterpret_cast<type>() del C++ (sconsigliati)

Da C++11 si può definire una variabile via keyword "auto"
Errore di compilazione solo se non si riesce a dedurre il tipo effettivo

Costanti
constexpr: C++11, è possibile valutare il valore durante la compilazione
const: la variabile non deve essere modificata

Enumerazioni
enum: ereditati dal C, un nome con assegnato un valore int
    enum { <ENUM_VALUE> [= N]  [, ...] }
    es: enum { SAT = 0, SUN };
        cout << ALPHA;
    per default i valori assegnati agli enum vanno da zero in su
enum class: C++11, hanno uno scope e un tipo proprio
    enum class <EnumName> [: integral_type] { <ENUM_VALUE> [= N]  [, ...] }
    es: enum class WeekendDay : bool { SAT = 0, SUN };
        cout << static_cast<int>(GreekLetter::ALPHA);
    per default l'integral_type di riferimento per una enum class è int
